import com.silentmatt.dss.*;
import com.silentmatt.dss.bool.*;
import com.silentmatt.dss.calc.*;
import com.silentmatt.dss.directive.*;
import com.silentmatt.dss.term.*;
import java.util.*;

COMPILER CSS3

    public DSSDocument CSSDoc;

        boolean partOfHex(String value) {
            if (value.length() == 7) { return false; }
            if (value.length() + la.val.length() > 7) { return false; }
            List<String> hexes = Arrays.asList(new String[] { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "a", "b", "c", "d", "e", "f" });
            for (int i = 0; i < la.val.length(); i++) {
                char c = la.val.charAt(i);
                if (!hexes.contains(String.valueOf(c))) {
                    return false;
                }
            }
            return true;
        }
        boolean isUnit() {
            if (la.kind != 1) { return false; }
            List<String> units = Arrays.asList(new String[] { "em", "ex", "px", "gd", "rem", "vw", "vh", "vm", "ch", "mm", "cm", "in", "pt", "pc", "deg", "grad", "rad", "turn", "ms", "s", "hz", "khz", "dpi", "dpcm" });            return units.contains(la.val);
        }
        boolean isDeclaration() {
            return la.kind == _ident && scanner.Peek().val.equals(":");
        }
        boolean isNestedSelector() {
            Token next = la;
            while (!next.val.equals(";") && !next.val.equals("}")) {
                if (next.val.equals("{")) {
                    return true;
                }
                next = scanner.Peek();
            }
            return false;
        }
        boolean endOfBlock() {
            return la.val.equals("}");
        }

/*------------------------------------------------------------------------*
 *----- SCANNER DESCRIPTION ----------------------------------------------*
 *------------------------------------------------------------------------*/

CHARACTERS

    tab                = '\u0009'. /*  9 = tabulator */
    eol                = '\u000a'. /* 10 = line feed */
    cr                 = '\u000d'. /* 13 = carriage return */
    newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
    space              = ' '.

    letter             = 'A' .. 'Z' + 'a' .. 'z' + '_'.
    digit              = "0123456789".
    hexDigit           = digit + "ABCDEFabcdef".
    notDigit           = ANY - digit.

    char               = ANY - "'" - '\\' - newLine.
    verbatimStringChar = ANY - '"'.
    regularStringChar  = ANY - '"' - '\\' - newLine.
    notNewLine         = ANY - newLine .
    ws                 = " " + tab + '\u000b' + '\u000c'. /* Any character with Unicode class Zs */
    nonascii           = '\u0080' .. '\ud7ff' + '\ue000' .. '\ufffd' /* + '\u10000' .. '#x10ffff' */ .
    wc                 = tab + eol + '\u000c' + cr + ' '.
    escape_chars       = ' ' .. '\u007e' + '\u0080' .. '\ud7ff' + '\ue000' .. '\ufffd' /* + '\u10000' .. '\u10FFFF'*/ .
    dqStringChar       = ANY - '\"' - '\\' - '\u000d' - '\u000a'.
    sqStringChar       = ANY - '\'' - '\\' - '\u000d' - '\u000a'.
    zeroToThree        = "0123".
    octalDigit         = "01234567".
    not_rp             = ANY - ')'.

TOKENS

    ident = ['-'] (letter | nonascii | (('\\' hexDigit [ hexDigit hexDigit hexDigit hexDigit hexDigit ] [ wc ]) | ('\\' escape_chars))) { letter | digit | '-' | nonascii | (('\\' hexDigit [ hexDigit hexDigit hexDigit hexDigit hexDigit ] [ wc ]) | ('\\' escape_chars)) }.
    atref = '@' ['-'] (letter | nonascii | (('\\' hexDigit [ hexDigit hexDigit hexDigit hexDigit hexDigit ] [ wc ]) | ('\\' escape_chars))) { letter | digit | '-' | nonascii | (('\\' hexDigit [ hexDigit hexDigit hexDigit hexDigit hexDigit ] [ wc ]) | ('\\' escape_chars)) }.
    integer = digit {digit}.
    decimal = {digit} '.' {digit}.
    stringLit =
      ("\"" { dqStringChar
           | "\\" ( "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\" | "\n"
                  | "u" { "u" } hexDigit hexDigit hexDigit hexDigit
                  | zeroToThree [ octalDigit ] [ octalDigit ]
                  | octalDigit [ octalDigit ]
                  )
           }
      "\"")
    |
      ("\'" { sqStringChar
           | "\\" ( "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\" | "\n"
                  | "u" { "u" } hexDigit hexDigit hexDigit hexDigit
                  | zeroToThree [ octalDigit ] [ octalDigit ]
                  | octalDigit [ octalDigit ]
                  )
           }
      "\'").

    url = "url(" ( ("\"" { dqStringChar
           | "\\" ( "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\" | "\n"
                  | "u" { "u" } hexDigit hexDigit hexDigit hexDigit
                  | zeroToThree [ octalDigit ] [ octalDigit ]
                  | octalDigit [ octalDigit ]
                  )
           }
      "\"")
    |
      ("\'" { sqStringChar
           | "\\" ( "b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\" | "\n"
                  | "u" { "u" } hexDigit hexDigit hexDigit hexDigit
                  | zeroToThree [ octalDigit ] [ octalDigit ]
                  | octalDigit [ octalDigit ]
                  )
           }
      "\'")
    |
      { not_rp } ) ")".

PRAGMAS

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO '\n'

IGNORE eol + cr + tab + space

PRODUCTIONS

/*------------------------------------------------------------------------*
 *--------------------------- Declarations -------------------------------*
 *------------------------------------------------------------------------*/

CSS3 =                      (. CSSDoc = new DSSDocument(); .)
    {"<!--" | "-->"}
    {
        rule<out Rule rule> (. CSSDoc.addRule(rule); .)
        {"<!--" | "-->"}
    }
.

rule<out Rule rule> (. rule = null; .) =
    ruleset<out rule>
    |
    directive<out rule>
.

QuotedString<out String qs> = stringLit (. qs = t.val; .) .

URI<out String url> = url (. url = t.val.substring(4, t.val.length() - 1); .) .

medium<out Medium m> =  (. m = Medium.all; .)
    (
        "all"           (. m = Medium.all; .)
        | "aural"       (. m = Medium.aural; .)
        | "braille"     (. m = Medium.braille; .)
        | "embossed"    (. m = Medium.embossed; .)
        | "handheld"    (. m = Medium.handheld; .)
        | "print"       (. m = Medium.print; .)
        | "projection"  (. m = Medium.projection; .)
        | "screen"      (. m = Medium.screen; .)
        | "tty"         (. m = Medium.tty; .)
        | "tv"          (. m = Medium.tv; .)
    )
.

identity<out String ident> =
    (
        ident
        | "n"
        | "url"
        | "all"
        | "aural"
        | "braille"
        | "embossed"
        | "handheld"
        | "print"
        | "projection"
        | "screen"
        | "tty"
        | "tv"
        | "important"
        | "global"
        | "calc"
        | "only"
        | "not"
        | "and"
        | "literal"
        | "const"
        | "param"
        | "prop"
        | "ruleset"
    )   (. ident = t.val; .)
.

atReference<out String ident> = atref  (. ident = t.val.substring(1); .) .

mediaQuery<out MediaQuery query> =                      (.  String expr, q = ""; .)
    ( (
        [ "only"                                        (.  q = "only "; .)
          |
          "not"                                         (.  q = "not "; .)
        ]
        identity<out String type>                       (.  q += type; .)
        {
          "and" mediaExpression<out expr>               (.  q += " and " + expr; .)
        }
      )
    |
      (
        mediaExpression<out expr>                       (.  q += expr; .)
        {
            "and" mediaExpression<out expr>             (.  q += " and " + expr; .)
        }
      )
    )                                                   (.  query = new MediaQuery(q); .)
.

mediaExpression<out String expr> =
    "("
        identity<out String e>                          (.  expr = e; .)
        [
            ":" expr<out Expression exp>                (.  expr += ":" + exp; .)
        ]
    ")"                                                 (.  expr = "(" + expr + ")"; .)
.

mediaDirective<out MediaDirective mdir> =               (.
                                                            List<MediaQuery> media = new ArrayList<MediaQuery>();
                                                            List<Rule> rules = new ArrayList<Rule>();
                                                        .)
    "@media"
    mediaQuery<out MediaQuery m>                        (.  media.add(m); .)
    { ',' mediaQuery<out m>                             (.  media.add(m); .) }
    '{'
        {
            ruleset<out RuleSet rset>                   (.  rules.add(rset); .)
            |
            classDirective<out ClassDirective cdir>     (.  rules.add(cdir); .)
            |
            defineDirective<out DefineDirective ddir>   (.  rules.add(ddir); .)
            |
            includeDirective<out IncludeDirective idir> (.  rules.add(idir); .)
        }
    '}'                                                 (.  mdir = new MediaDirective(media, rules); .)
.

ifDirective<out IfDirective idir> = (.
                                        BooleanExpression expr;
                                        List<Rule> ifrules = new ArrayList<Rule>();
                                        List<Rule> elserules = null;
                                    .)
    "@if"
    booleanExpression<out expr>
    '{' {
        rule<out Rule rule>         (.  ifrules.add(rule); .)
    } '}'
    [
        "@else"                     (.  elserules = new ArrayList<Rule>(); .)
        '{' {
            rule<out Rule rule>     (.  elserules.add(rule); .)
        } '}'
    ]
    (.  idir = new IfDirective(expr, ifrules, elserules); .)
.

ifDeclarations<out DeclarationBlock mdecs> =    (.  BooleanExpression expr;
                                                    BooleanExpression elseExpr;
                                                    List<Declaration> decList = new ArrayList<Declaration>();
                                                    List<Declaration> decs;
                                                    DeclarationBlock ifBlock;
                                                    DeclarationBlock elseBlock;
                                                    List<NestedRuleSet> nestedRuleSets = new ArrayList<NestedRuleSet>();
                                                    List<Rule> rules = new ArrayList<Rule>();
                                                .)
(
    "@if"
    booleanExpression<out expr>                 (.  elseExpr = new NotExpression(expr); .)
    declarationBlock<out ifBlock>               (.
                                                    for (Declaration dec : ifBlock.getDeclarations()) {
                                                        decList.add(dec.withCondition(expr));
                                                    }
                                                    for (NestedRuleSet rule : ifBlock.getNestedRuleSets()) {
                                                        nestedRuleSets.add(rule.withCondition(expr));
                                                    }
                                                    for (Rule rule : ifBlock.getRules()) {
                                                        if (rule instanceof DefineDirective) {
                                                            rules.add(((DefineDirective)rule).withCondition(expr));
                                                        }
                                                        else {
                                                            Expect(38);
                                                        }
                                                    }
                                                .)
    [
        "@else"
        declarationBlock<out elseBlock>         (.
                                                    for (Declaration dec : elseBlock.getDeclarations()) {
                                                        decList.add(dec.withCondition(elseExpr));
                                                    }
                                                    for (NestedRuleSet rule : elseBlock.getNestedRuleSets()) {
                                                        nestedRuleSets.add(rule.withCondition(elseExpr));
                                                    }
                                                    for (Rule rule : elseBlock.getRules()) {
                                                        if (rule instanceof DefineDirective) {
                                                            rules.add(((DefineDirective)rule).withCondition(elseExpr));
                                                        }
                                                        else {
                                                            Expect(38);
                                                        }
                                                    }
                                                .)
    ]
)                                               (.  mdecs = new DeclarationBlock(new DeclarationList(decList), nestedRuleSets, rules); .)
.

parameter<out Declaration dec> =        (. Declaration.Builder decb = new Declaration.Builder(); .)
    identity<out String ident>          (. decb.setName(ident); .)
    [
        ':' expr<out Expression exp>    (. decb.setExpression(exp); .)
    ]
                                        (. dec = decb.build(); .)
.

declarationBlock<out DeclarationBlock block> =
                                        (.  DeclarationBlock.Builder builder = new DeclarationBlock.Builder();
                                            List<Declaration> decs;
                                            DeclarationBlock ifdecs;
                                        .)
    '{' {
        (IF (!isNestedSelector())
            multideclaration<out decs>  (.  builder.addDeclarations(decs);
                                            if (endOfBlock()) {
                                                break;
                                            }
                                        .)
            ';'
        )
        |
        ifDeclarations<out ifdecs>      (.  builder.addDeclarations(ifdecs.getDeclarations().toList());
                                            builder.addNestedRuleSets(ifdecs.getNestedRuleSets());
                                            builder.addRules(ifdecs.getRules());
                                        .)
        |
        classDirective<out Rule dir>    (.  builder.addRule(dir); .)
        |
        defineDirective<out Rule dir>   (.  builder.addRule(dir); .)
        |
                                        (.  Combinator cb = Combinator.Descendant; .)
        [ '&' ]                         (.  if (t.pos + t.val.length() == la.pos) {
                                                cb = Combinator.None;
                                            }
                                        .)
        [ '+'                           (.  cb = Combinator.PrecededImmediatelyBy; .)
        | '>'                           (.  cb = Combinator.ChildOf; .)
        | '~'                           (.  cb = Combinator.PrecededBy; .)
        ] ruleset<out RuleSet nested>   (.  builder.addNestedRuleSet(cb, nested, BooleanExpression.TRUE); .)
    } '}'                               (.  block = builder.build(); .)
.

classDirective<out ClassDirective dir> =    (.  String ident;
                                                List<Declaration> parameters = new ArrayList<Declaration>();
                                                Declaration param;
                                                boolean global = false;
                                            .)
    "@class"
    identity<out ident>
    [
        '<'
            [   parameter<out param>        (.  parameters.add(param); .)
                {   ';'
                    parameter<out param>    (.  parameters.add(param); .)
                }
            ]
        '>'
    ]
    [
        "global"                            (.  global = true; .)
    ]
    declarationBlock<out DeclarationBlock block>
                                            (.  dir = new ClassDirective(ident, new DeclarationList(parameters), global, block); .)
.

defineDirective<out DefineDirective dir> =      (.
                                                    List<Declaration> declarations = new ArrayList<Declaration>();
                                                    boolean global = false;
                                                    List<Declaration> mdecs;
                                                .)
    "@define"
    [ "global"                                  (.  global = true; .) ]
    '{'
        { multideclaration<out mdecs>           (.  declarations.addAll(mdecs);
                                                    if (endOfBlock()) {
                                                        break;
                                                    }
                                                .)
          ';' }
    '}'                                         (.  dir = new DefineDirective(new DeclarationList(declarations), global, BooleanExpression.TRUE); .)
.

fontFaceDirective<out FontFaceDirective dir> =  (.  List<Declaration> declarations = new ArrayList<Declaration>();
                                                    List<Declaration> mdecs;
                                                .)
    "@font-face"
    '{' { multideclaration<out mdecs>
                                                (.  declarations.addAll(mdecs);
                                                    if (endOfBlock()) {
                                                        break;
                                                    }
                                                .)
        ';' } '}'                               (.  dir = new FontFaceDirective(new DeclarationList(declarations)); .)
.

pageDirective<out PageDirective dir> =          (.  List<Declaration> declarations = new ArrayList<Declaration>();
                                                    SimpleSelector ss = null;
                                                    List<Declaration> mdecs;
                                                .)
    "@page"
    [ pseudo<out String psd>                    (.  ss = new SimpleSelector();
                                                    ss = ss.withPseudo(psd);
                                                .)
    ]
    '{' { multideclaration<out mdecs>           (.  declarations.addAll(mdecs);
                                                    if (endOfBlock()) {
                                                        break;
                                                    }
                                                .)
          ';' } '}'                             (.  dir = new PageDirective(ss, new DeclarationList(declarations)); .)
.

importDirective<out ImportDirective dir> =
                        (.  MediaQuery m = new MediaQuery("all");
                            UrlTerm trm;
                        .)
    "@import"
    URI<out String url> (.  trm = new UrlTerm(url); .)
    [ mediaQuery<out m> ]
    ';'                 (.  dir = new ImportDirective(trm, m); .)
.

includeDirective<out IncludeDirective dir> =
                                            (.  boolean literal = false;
                                                List<Declaration> declarations = new ArrayList<Declaration>();
                                                UrlTerm includeUrl = null;
                                                List<Declaration> mdecs;
                                            .)
    "@include"
    [
        "literal"                           (.  literal = true; .)
    ]
    (
        URI<out String url>                 (.  includeUrl = new UrlTerm(url); .)
        |
        QuotedString<out String url>        (.  includeUrl = new UrlTerm(url.substring(1, url.length()-1)); .)
    )
    (
        ';'
        |
        '{'
            { multideclaration<out mdecs>   (.  declarations.addAll(mdecs);
                                                if (endOfBlock()) {
                                                    break;
                                                }
                                            .)
            ';' }
        '}'
    )                                       (.  dir = new IncludeDirective(includeUrl, literal, declarations); .)
.

charsetDirective<out CharsetDirective dir> =
    "@charset"
    term<out Term trm>   (. dir = new CharsetDirective(trm); .)
    ';'
.

namespaceDirective<out NamespaceDirective dir> =            (.  String ident = null;
                                                                String url = null;
                                                            .)
    "@namespace"
    [ identity<out ident> ]
    ( URI<out url> | QuotedString<out url> ) ';'            (.  dir = new NamespaceDirective(ident, new UrlTerm(url)); .)
.

genericDirective<out GenericDirective dir> =
    atReference<out String ident>                       (.  GenericDirective.Builder dirb = new GenericDirective.Builder();
                                                            dirb.setName("@" + ident);
                                                        .)
    [
        expr<out Expression exp>                        (.  dirb.setExpression(exp); .)
        |
        medium<out Medium m>                            (.  dirb.addMedium(m); .)
    ]
    (
        '{'
            {
                ruleset<out RuleSet rset>               (.  dirb.addRule(rset); .)
                |
                // XXX: Order between Declarations and Rules is not preserved.
                // TODO: Support multideclarations in generic directives
                declaration<out Declaration dec>        (.  dirb.addDeclaration(dec);
                                                            if (endOfBlock()) {
                                                                break;
                                                            }
                                                        .)
                ';'
                |
                directive<out Rule dr>                  (.  dirb.addRule(dr); .)
            }
        '}'
        |
        ';'
    )                                                   (.  dir = dirb.build(); .)
.

directive<out Rule dir> (.  dir = null; .) =
    ifDirective<out dir>
    |
    mediaDirective<out dir>
    |
    classDirective<out dir>
    |
    defineDirective<out dir>
    |
    fontFaceDirective<out dir>
    |
    // TODO: Look up where @import can be
    importDirective<out dir>
    |
    includeDirective<out dir>
    |
    // TODO: Look up where @charset can be
    charsetDirective<out dir>
    |
    pageDirective<out dir>
    |
    // TODO: Look up where @charset can be
    namespaceDirective<out dir>
    |
    genericDirective<out dir>
.

ruleset<out RuleSet rset> =                 (.  RuleSet.Builder rsetb = new RuleSet.Builder();
                                                Selector sel;
                                                List<Declaration> decs;
                                                Rule dir;
                                                Combinator cb;
                                            .)

    selector<out sel>                       (.  rsetb.addSelector(sel); .)
    { ',' selector<out sel>                 (.  rsetb.addSelector(sel); .)
    }
    declarationBlock<out DeclarationBlock block>
                                            (.  rsetb.setDeclarationBlock(block);
                                                rset = rsetb.build();
                                            .)
.

selector<out Selector sel> =    (.  Selector.Builder selb = new Selector.Builder();
                                    SimpleSelector ss;
                                    Combinator cb = Combinator.Descendant;
                                .)
    simpleselector<out ss>      (.  selb.addSimpleSelector(ss); .)
    { [ ('+'                    (.  cb = Combinator.PrecededImmediatelyBy; .)
        | '>'                   (.  cb = Combinator.ChildOf; .)
        | '~'                   (.  cb = Combinator.PrecededBy; .)
        ) ]
        simpleselector<out ss>  (.  ss = ss.withCombinator(cb);
                                    selb.addSimpleSelector(ss);
                                    cb = Combinator.Descendant;
                                .)
    }                           (.  sel = selb.build(); .)
.
simpleselector<out SimpleSelector ss> = (. SimpleSelector.Builder ssb = new SimpleSelector.Builder();
                                            SimpleSelector.Builder parent = ssb;
                                            String ident;
                                        .)
    (identity<out ident>                (.  ssb.setElementName(ident); .)
    | '*'                               (.  ssb.setElementName("*"); .)
    | ('#' identity<out ident>          (.  ssb.setID(ident); .)
        | '.' identity<out ident>       (.  ssb.setClassName(ident); .)
        | attrib<out Attribute atb>     (.  ssb.setAttribute(atb); .)
        | pseudo<out String psd>        (.  ssb.setPseudo(psd); .)
        )
    )
    {                                   (.  if (t.pos + t.val.length() < la.pos) {
                                                break;
                                            }
                                            SimpleSelector.Builder child = new SimpleSelector.Builder();
                                        .)
        ('#' identity<out ident>        (.  child.setID(ident); .)
        | '.' identity<out ident>       (.  child.setClassName(ident); .)
        | attrib<out Attribute atb>     (.  child.setAttribute(atb); .)
        | pseudo<out String psd>        (.  child.setPseudo(psd); .)
        )                               (.  parent.setChild(child);
                                            parent = child;
                                        .)
    }                                   (.  ss = ssb.build(); .)
.

attrib<out Attribute atb> =         (.  Attribute.Builder atbb = new Attribute.Builder();
                                        String quote;
                                        String ident;
                                    .)
    '[' identity<out ident>         (.  atbb.setOperand(ident); .)
    [
        ( '='                       (.  atbb.setOperator(AttributeOperator.Equals); .)
        | "~="                      (.  atbb.setOperator(AttributeOperator.InList); .)
        | "|="                      (.  atbb.setOperator(AttributeOperator.Hyphenated); .)
        | "$="                      (.  atbb.setOperator(AttributeOperator.EndsWith); .)
        | "^="                      (.  atbb.setOperator(AttributeOperator.BeginsWith); .)
        | "*="                      (.  atbb.setOperator(AttributeOperator.Contains); .)
        )
        ( identity<out ident>       (.  atbb.setValue(ident); .)
        | QuotedString<out quote>   (.  atbb.setValue(quote); .)
        | (integer | decimal)       (.  atbb.setValue(t.val); .)
        )
    ] ']'                           (.  atb = atbb.build(); .)
.

pseudo<out String pseudo> =         (.  StringBuilder sb = new StringBuilder();
                                        boolean haveOpenParen = false;
                                    .)
    ':' [ ':'                       (.  sb.append(":"); .) ]
    ( identity<out String ident>    (.  sb.append(ident); .)
      |
      "not"                         (.  sb.append("not"); .)
    )
    [ '('
        (( [ "+"                    (.  sb.append("(").append(t.val);
                                        haveOpenParen = true; .)
             |
             "-"                    (.  sb.append("(").append(t.val);
                                        haveOpenParen = true; .)
           ]
           [ integer                (.  if (!haveOpenParen) {
                                            sb.append("(");
                                            haveOpenParen = true;
                                        }
                                        sb.append(t.val); .)
           ]
           [  ("n" | "-n")          (.  if (!haveOpenParen) {
                                            sb.append("(");
                                            haveOpenParen = true;
                                        }
                                        sb.append(t.val); .)
                [
                    ("+" | "-")     (.  sb.append(t.val); .)
                    integer         (.  sb.append(t.val); .)
                ]
           ]
        )                           (.  sb.append(")"); .)
        |
        simpleselector<out SimpleSelector ss>
                                    (.  sb.append("(").append(ss).append(")"); .)
        )
    ')'
    ]                               (.  pseudo = sb.toString(); .)
.

declaration<out Declaration dec> =  (. Declaration.Builder decb = new Declaration.Builder(); .)
    identity<out String ident>      (. decb.setName(ident); .)
    ':' expr<out Expression exp>    (. decb.setExpression(exp); .)
    [ '!' "important"               (. decb.setImportant(true); .) ]
                                    (. dec = decb.build(); .)
.

multideclaration<out List<Declaration> decs> =  (.  ArrayList<Declaration.Builder> decbs = new ArrayList<Declaration.Builder>();
                                                    Declaration.Builder first = new Declaration.Builder();
                                                .)
    (( identity<out String ident>               (.  first.setName(ident); decbs.add(first); .)
       {',' identity<out String ident2>         (.  decbs.add(new Declaration.Builder().setName(ident2).setExpression(new PropertyTerm(first.getName()).toExpression())); .)}
     )
        ':' expr<out Expression exp>            (.  first.setExpression(exp); .)
        [ '!' "important"                       (.  for (Declaration.Builder decb : decbs) {
                                                        decb.setImportant(true);
                                                    }
                                                .) ]
    )                                           (.  decs = new ArrayList<Declaration>(decbs.size());
                                                    for (Declaration.Builder decb : decbs) {
                                                        decs.add(decb.build());
                                                    } .)
.

expr<out Expression exp> =  (.  Expression.Builder expb = new Expression.Builder();
                                Character sep = null;
                                Term trm;
                            .)
    term<out trm>           (.  expb.addTerm(trm); .)
    { [ ('/'                (.  sep = '/'; .)
        | ','               (.  sep = ','; .)
        | '='               (.  sep = '='; .)
        ) ]
        term<out trm>       (.
                                if (sep != null) { trm = trm.withSeparator(sep); }
                                expb.addTerm(trm);
                                sep = null;
                            .)
    }                       (.  exp = expb.build(); .)
.

booleanExpression<out BooleanExpression expr> =
    orExpression<out expr>
.

orop<out BooleanOperation op> (. op = null; .) = "||" (. op = BooleanOperation.OR; .) | '^' (. op = BooleanOperation.XOR; .).

orExpression<out BooleanExpression expr> = (. BooleanExpression left, right; BooleanOperation op; .)
    andExpression<out left> (. expr = left; .)
    {
        orop<out op> andExpression<out right> (. expr = new BinaryBooleanExpression(op, expr, right); .)
    }
.

andExpression<out BooleanExpression expr> = (. BooleanExpression left, right;.)
    notExpression<out left> (. expr = left; .)
    {
        "&&" notExpression<out right> (. expr = new BinaryBooleanExpression(BooleanOperation.AND, expr, right); .)
    }
.

notExpression<out BooleanExpression expr> (. BooleanExpression exp; expr = null; .) =
    primaryBooleanExpression<out exp> (. expr = exp; .)
    |
    '!' notExpression<out exp> (. expr = new NotExpression(exp); .)
.

primaryBooleanExpression<out BooleanExpression expr> (. expr = null; Term trm; BooleanExpression exp; .) =
    '(' booleanExpression<out exp> ')' (. expr = exp; .)
    |
    term<out trm> (. expr = new TermBooleanExpression(trm); .)
.

lengthExpression<out CalcExpression expr> =
    additiveExpression<out expr>
.

addop<out Operation op> (. op = null; .) = '+' (. op = Operation.Add; .) | '-' (. op = Operation.Subtract; .).
mulop<out Operation op> (. op = null; .) = '*' (. op = Operation.Multiply; .) | '/' (. op = Operation.Divide; .).

additiveExpression<out CalcExpression expr> = (. CalcExpression left, right; Operation op; .)
    multiplicativeExpression<out left> (. expr = left; .)
    {
        addop<out op> multiplicativeExpression<out right> (. expr = new BinaryExpression(op, expr, right); .)
    }
.

multiplicativeExpression<out CalcExpression expr> = (. CalcExpression left, right; Operation op; .)
    termExpression<out left> (. expr = left; .)
    {
        mulop<out op> termExpression<out right> (. expr = new BinaryExpression(op, expr, right); .)
    }
.

termExpression<out CalcExpression expr> (.  expr = null; Term trm; CalcExpression exp; .) =
    '-' termExpression<out exp>         (. expr = new NegationExpression(exp); .)
    |
    '(' lengthExpression<out exp> ')'   (. expr = exp; .)
    |
    term<out trm>                       (. expr = new TermExpression(trm); .)
.

literalCalculation<out CalculationLiteralTerm trm> =    (.  CalcExpression expr = null;
                                                            String prefix = ""; .)
((("calc" | "-webkit-calc" | "-o-calc" | "-ms-calc" | "-moz-calc")
                                                        (.  prefix = t.val.replace("calc", ""); .)
        "(" lengthExpression<out expr> ")")
|
(       "[" lengthExpression<out expr> "]"))            (.  trm = new CalculationLiteralTerm(prefix, expr); .)
.

calculation<out CalcExpression expr> =  (.  expr = null; .)
(("@calc" "(" lengthExpression<out expr> ")")
|
(       "[" lengthExpression<out expr> "]"))
.

term<out Term trm> =                        (.  String val = "";
                                                Expression exp;
                                                String ident;
                                                CalcExpression expression;
                                                trm = null;
                                            .)
    (
        QuotedString<out val>               (.  trm = new StringTerm(val); .)
        |
        URI<out val>                        (.  trm = new UrlTerm(val); .)
        |
        "const" '(' identity<out ident> ')' (.  trm = new ConstTerm(ident); .)
        |
        "param" '(' identity<out ident> ')' (.  trm = new ParamTerm(ident); .)
        |
        "prop" '(' identity<out ident> ')'  (.  trm = new PropertyTerm(ident); .)
        |
        atReference<out ident>              (.  trm = new AtReferenceTerm(ident); .)
        |
        "ruleset" '(' selector<out Selector s> ')'
                                            (.  trm = new RuleSetClassReferenceTerm(s); .)
        |
        "U\\" identity<out ident>           (.  trm = new UnicodeTerm("U\\" + ident); .)
        |
        HexValue<out val>                   (.  trm = new HexTerm(val); .)
        |
        calculation<out expression>         (.  trm = new CalculationTerm(expression); .)
        |
        literalCalculation<out trm>
        |
        identity<out ident>                 (.  String trmValue = ident; .)
        { ':'                               (.  trmValue += t.val; .)
            [ ':'                           (.  trmValue += t.val; .)
            ]
            identity<out ident>             (.  trmValue += ident; .)
            |
            '.'                             (.  trmValue += t.val; .)
            identity<out ident>             (.  trmValue += ident; .)
/*            |
            '='                             (.  trmValue += t.val; .)
            (   identity<out ident>         (.  trmValue += ident; .)
                |
                integer                     (.  trmValue += t.val; .)
            )
*/
        }                                   (.  trm = new StringTerm(trmValue); .)
        [
            '(' expr<out exp>               (.  trm = new FunctionTerm(trm.toString(), exp); .)
            ')'
            |
            ('<'                            (.  ClassReferenceTerm.Builder cls = new ClassReferenceTerm.Builder(trm.toString());
                                                Declaration dec;
                                            .)
                [ ( IF(isDeclaration()) declaration<out dec>
                                            (.  cls.addArgument(dec); .)
                    |
                    expr<out Expression arg>
                                            (.  cls.addArgument(new Declaration("", arg)); .)
                  )
                  { ';'
                    ( IF(isDeclaration()) declaration<out dec>
                                            (.  cls.addArgument(dec); .)
                      |
                      expr<out Expression arg>
                                            (.  cls.addArgument(new Declaration("", arg)); .)
                    )
                  }
                ]
            '>')                            (.  trm = cls.build(); .)
        ]
        |
        [   '-'                             (.  val = "-"; .)
            |
            '+'                             (.  val = "+"; .)
        ]
        ( integer | decimal )               (.  val += t.val; trm = new NumberTerm(Double.parseDouble(val)); .)
        (
            IF (endOfBlock())               (.  trm = ((NumberTerm) trm).withValue(Double.parseDouble(val)); .)
            |
            (
                // TODO: This gets lost because val isn't used to construct the NumberTerm
                IF(la.val.equalsIgnoreCase("n"))
                (
                /* func(4n+1) */
                    "n"                     (.  val += t.val; .)
                    [ ( "+"                 (.  val += '+'; .)
                        |
                        "-"                 (.  val += '-'; .)
                      )
                        integer             (.  val += t.val; .)
                    ]
                )                           (. trm = new StringTerm(val); val = ""; .)
                |                           // TODO: Do we know trm is a NumberTerm?
                "%"                         (.  trm = ((NumberTerm) trm).withUnit(Unit.Percent); .)
                |
                [
                    IF(isUnit())
                        identity<out ident> (.  try {
                                                    // TODO: What if trm isn't a NumberTerm?
                                                    trm = ((NumberTerm) trm).withUnit(Unit.parse(ident));
                                                } catch (IllegalArgumentException ex) {
                                                    errors.SemErr(t.line, t.col, "Unrecognized unit '" + ident + "'");
                                                }
                                            .)
                ]
            )                               (.  if (trm instanceof NumberTerm) {
                                                    trm = ((NumberTerm) trm).withValue(Double.parseDouble(val));
                                                }
                                                else if (trm instanceof StringTerm) {
                                                    trm = new StringTerm(((StringTerm)trm).getValue() + val);
                                                }
                                            .)
        )
    )
.

HexValue<out String val> =  (.  StringBuilder sb = new StringBuilder();
                                boolean found = false;
                            .)
    '#'                     (.  sb.append(t.val); .)
    (
        integer             (.  sb.append(t.val); .)
        |
        ident               (.  sb.append(t.val); found = true; .)
    )
    [   IF(!found && partOfHex(sb.toString()))
            ident           (.  sb.append(t.val); .)
    ]                       (.  val = sb.toString(); .)
.

END CSS3.
